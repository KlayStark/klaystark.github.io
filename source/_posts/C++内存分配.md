---
title: C++内存管理
date: 2021-7-05 12:08:12
categories: C++
tags:
---

## C++内存分配

参考：[C++内存管理详解](https://www.cnblogs.com/learning-zjx/p/10645659.html)、[自由存储区是否等价于堆](https://www.cnblogs.com/QG-whz/p/5060894.html)

五个区：栈、堆、自由存储区、常量存储区、全局/静态存储区。

---

### 栈

编译器自动分配释放，存放**函数的参数值、局部变量**等值。

### 堆

使用malloc/free动态分配和释放空间。

### 自由存储区

通过new和delete分配和释放空间的内存。

### 常量存储区

存放常量。

### 全局/静态存储区

初始化的全局变量和静态变量在一块区域，未初始化的全局变量和静态变量在相邻的另一块区域。程序结束后由系统释放。

### 堆与自由存储区的区别

堆是C语言和操作系统的术语、是操作系统维护的一块内存，而自由存储是C++中通过new与delete动态分配和释放对象的抽象概念。堆与自由存储区并不等价。基本上，所有的C++编译器默认使用堆来实现自由存储。

## new/delete和malloc/free的区别

*（即C++和C做内存分配和释放的区别）*

new/delete是C++语言的运算符，malloc/free是C语言中的库函数。

>对于非内部数据类型的对象而言，光用maloc/free无法满足动态对象的要求。对象在创建的同时要自动执行构造函数，对象在消亡之前要自动执行析构函数。由于malloc/free是库函数而不是运算符，不在编译器的控制权限之内，不能够把执行构造函数和析构函数的任务强加于malloc/free。

具体区别：
1. 对于类对象，**new会调用构造函数和析构函数，malloc不会**；
2. new是从自由存储区获得内存，malloc从堆中获取内存；
3. new分配内存空间无需指定分配内存大小，malloc需要；
4. new返回类型指针，类型安全，malloc返回void*，再强制转换成所需要的类型。

## 内存对齐

### 定义

内存对齐指的是C++结构体中的数据成员，其内存地址是否为其对齐字节大小的倍数。

### 需要内存对齐的原因

关键在于CPU存取数据的效率问题。为了提高效率，计算机从内存中取数据是按照一个固定长度的。比如在32位机上，CPU每次都是取32bit数据的，也就是4字节；若不进行对齐，要取出两块地址中的数据，进行掩码和移位等操作，写入目标寄存器内存，效率很低。内存对齐一方面可以节省内存，一方面可以提升数据读取的速度。

### 对齐规则

1. 结构体第一个成员的**偏移量（offset）**为0，以后每个成员相对于结构体首地址的 offset 都是该成员大小与有效对齐值中较小那个的整数倍，如有需要编译器会在成员之间加上填充字节。

2. **结构体的总大小为 有效对齐值 的整数倍**，如有需要编译器会在最末一个成员之后加上填充字节。

解释：

每个特定平台上的编译器都有自己的默认“对齐系数”（也叫对齐模数）。gcc中默认#pragma pack(4)，可以通过预编译命令#pragma pack(n)，n = 1,2,4,8,16来改变这一系数。

有效对其值：是给定值#pragma pack(n)和结构体中最长数据类型长度中较小的那个。有效对齐值也叫对齐单位。

参考：[C/C++内存对齐详解](https://zhuanlan.zhihu.com/p/30007037)
